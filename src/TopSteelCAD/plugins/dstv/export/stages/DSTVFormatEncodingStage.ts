/**
 * Stage d'encodage final au format DSTV
 * Génère le fichier DSTV final conforme à la norme
 */

import { BaseStage } from './BaseExportStage';
import { DSTVPluginConfig } from '../../DSTVPlugin';

export class DSTVFormatEncodingStage extends BaseStage {
  private config: DSTVPluginConfig;
  private readonly COMMENT_PREFIX = '**';
  private readonly LINE_ENDING = '\r\n'; // DSTV utilise CR+LF

  constructor(config: DSTVPluginConfig) {
    super({
      name: 'DSTV Format Encoding',
      description: 'Encodes data into final DSTV format'
    });
    this.config = config;
  }

  async process(context: any): Promise<any> {
    const data = context.output as any;
    
    // Construire le contenu DSTV final
    const content = this.encodeToDSTV(data);
    
    // Valider le format final
    this.validateDSTVFormat(content);
    
    // Ajouter les métadonnées finales
    context.metadata.encoding = {
      format: 'DSTV',
      version: '7.0',
      charset: 'ASCII',
      lineEnding: 'CRLF',
      size: content.length,
      lines: content.split(this.LINE_ENDING).length
    };
    
    context.output = content;
    
    return context;
  }

  private encodeToDSTV(data: any): string {
    const lines: string[] = [];
    
    // Ajouter l'en-tête avec commentaires si configuré
    if (this.config.enableDebugLogs) {
      lines.push(...this.createHeader(data));
    }
    
    // Encoder chaque bloc
    for (const block of data.blocks) {
      // Ajouter un commentaire avant le bloc si configuré
      if (this.config.enableDebugLogs && block.comment) {
        lines.push(`${this.COMMENT_PREFIX} ${block.comment}`);
      }
      
      // Ajouter les lignes du bloc
      lines.push(...this.encodeBlock(block));
    }
    
    // Ajouter le pied de page si configuré
    if (this.config.enableDebugLogs) {
      lines.push(...this.createFooter(data));
    }
    
    // Joindre avec le bon line ending
    return lines.join(this.LINE_ENDING);
  }

  private createHeader(data: any): string[] {
    const lines: string[] = [];
    const now = new Date();
    
    lines.push(`${this.COMMENT_PREFIX} DSTV File generated by TopSteelCAD`);
    lines.push(`${this.COMMENT_PREFIX} Format: DSTV 7th Edition (July 1998)`);
    lines.push(`${this.COMMENT_PREFIX} Date: ${now.toISOString()}`);
    lines.push(`${this.COMMENT_PREFIX} Blocks: ${data.metadata.blockCount}`);
    lines.push(`${this.COMMENT_PREFIX} Features: ${data.metadata.features.holes} holes, ${data.metadata.features.contours} contours, ${data.metadata.features.markings} markings`);
    lines.push(`${this.COMMENT_PREFIX}`);
    
    return lines;
  }

  private createFooter(data: any): string[] {
    const lines: string[] = [];
    
    lines.push(`${this.COMMENT_PREFIX}`);
    lines.push(`${this.COMMENT_PREFIX} End of DSTV file`);
    lines.push(`${this.COMMENT_PREFIX} Total lines: ${data.metadata.lineCount}`);
    
    return lines;
  }

  private encodeBlock(block: any): string[] {
    const encoded: string[] = [];
    
    for (const line of block.lines) {
      // Encoder la ligne selon le type
      const encodedLine = this.encodeLine(line, block.type);
      encoded.push(encodedLine);
    }
    
    return encoded;
  }

  private encodeLine(line: string | number | any, blockType: string): string {
    // Convertir en string si nécessaire
    let encoded: string;
    if (typeof line === 'string') {
      encoded = line;
    } else if (typeof line === 'number') {
      encoded = line.toString();
    } else if (line && typeof line === 'object') {
      // Si c'est un objet, essayer de le convertir en string
      encoded = JSON.stringify(line);
      console.warn('[DSTVExport] Warning: object passed to encodeLine:', line);
    } else {
      encoded = String(line || '');
    }
    
    // Appliquer les règles d'encodage DSTV
    encoded = this.applyDSTVRules(encoded, blockType);
    
    // Vérifier la longueur maximale
    if (encoded.length > 80) {
      if (this.config.strictMode) {
        throw new Error(`Line exceeds 80 character limit: ${encoded}`);
      } else {
        console.warn(`[DSTVExport] Line truncated from ${encoded.length} to 80 characters`);
        encoded = encoded.substring(0, 80);
      }
    }
    
    return encoded;
  }

  private applyDSTVRules(text: string | any, blockType: string): string {
    // S'assurer que text est une chaîne
    if (typeof text !== 'string') {
      text = String(text || '');
    }
    
    // Règles spécifiques DSTV
    
    // 1. Remplacer les caractères non-ASCII
    text = this.replaceNonASCII(text);
    
    // 2. Formater les nombres selon le contexte
    if (this.isNumericField(text, blockType)) {
      text = this.formatNumericField(text);
    }
    
    // 3. Padder certains champs si nécessaire
    text = this.padField(text, blockType);
    
    // 4. Convertir en majuscules pour certains champs
    if (this.shouldUpperCase(blockType)) {
      text = text.toUpperCase();
    }
    
    return text;
  }

  private replaceNonASCII(text: string | any): string {
    // S'assurer que text est une chaîne
    if (typeof text !== 'string') {
      text = String(text || '');
    }
    
    // Remplacer les caractères spéciaux par leurs équivalents ASCII
    const replacements: Record<string, string> = {
      'ä': 'ae',
      'ö': 'oe',
      'ü': 'ue',
      'Ä': 'AE',
      'Ö': 'OE',
      'Ü': 'UE',
      'ß': 'ss',
      '°': 'deg',
      'ø': 'o',
      'Ø': 'O',
      '±': '+/-',
      '²': '2',
      '³': '3',
      'µ': 'u',
      '€': 'EUR'
    };
    
    for (const [special, replacement] of Object.entries(replacements)) {
      text = text.replace(new RegExp(special, 'g'), replacement);
    }
    
    // Supprimer les autres caractères non-ASCII
    text = text.replace(/[^\x00-\x7F]/g, '');
    
    return text;
  }

  private isNumericField(text: string, blockType: string): boolean {
    // Vérifier si le champ doit être traité comme numérique
    const numericPattern = /^-?\d+(\.\d+)?$/;
    return numericPattern.test(text.trim());
  }

  private formatNumericField(text: string): string {
    const value = parseFloat(text);
    
    if (isNaN(value)) {
      return text;
    }
    
    // Format standard DSTV : ####.##
    // Arrondir à 2 décimales
    const formatted = value.toFixed(2);
    
    // Padder à gauche pour avoir au moins 7 caractères avant le point
    const parts = formatted.split('.');
    parts[0] = parts[0].padStart(4, ' ');
    
    return parts.join('.');
  }

  private padField(text: string, blockType: string): string {
    // Certains champs nécessitent un padding spécifique
    switch (blockType) {
      case 'ST':
        // Le type de profil doit avoir une longueur fixe
        if (text.match(/^[A-Z]+\d+$/)) {
          return text.padEnd(10, ' ');
        }
        break;
      
      case 'BO':
      case 'SI':
      case 'AK':
      case 'IK':
        // Les coordonnées sont déjà formatées
        break;
    }
    
    return text;
  }

  private shouldUpperCase(blockType: string): boolean {
    // Certains blocs doivent être en majuscules
    const upperCaseBlocks = ['ST', 'EN', 'BO', 'SI', 'AK', 'IK', 'SC', 'PU', 'KO'];
    return upperCaseBlocks.includes(blockType);
  }

  private validateDSTVFormat(content: string): void {
    const lines = content.split(this.LINE_ENDING);
    const errors: string[] = [];
    
    // Vérifier que le fichier commence par ST
    const firstNonComment = lines.find(line => !line.startsWith(this.COMMENT_PREFIX));
    if (firstNonComment !== 'ST') {
      errors.push('File must start with ST block');
    }
    
    // Vérifier que le fichier se termine par EN
    const lastNonComment = lines.reverse().find(line => !line.startsWith(this.COMMENT_PREFIX));
    lines.reverse(); // Remettre dans l'ordre
    if (lastNonComment !== 'EN') {
      errors.push('File must end with EN block');
    }
    
    // Vérifier la structure des blocs
    let inBlock = false;
    let currentBlock = '';
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      // Ignorer les commentaires
      if (line.startsWith(this.COMMENT_PREFIX)) {
        continue;
      }
      
      // Détecter les débuts de blocs
      if (this.isBlockStart(line)) {
        if (inBlock && currentBlock !== 'ST' && currentBlock !== 'EN') {
          // Certains blocs peuvent être imbriqués
        }
        inBlock = true;
        currentBlock = line;
      }
      
      // Vérifier la longueur de ligne
      if (line.length > 80) {
        errors.push(`Line ${i + 1} exceeds 80 characters`);
      }
      
      // Vérifier les caractères ASCII uniquement
      if (!/^[\x00-\x7F]*$/.test(line)) {
        errors.push(`Line ${i + 1} contains non-ASCII characters`);
      }
    }
    
    // En mode strict, lever une erreur si des problèmes sont détectés
    if (errors.length > 0 && this.config.strictMode) {
      throw new Error(`DSTV format validation failed:\n${errors.join('\n')}`);
    } else if (errors.length > 0) {
      console.warn('[DSTVExport] Format validation warnings:', errors);
    }
  }

  private isBlockStart(line: string): boolean {
    const blockTypes = [
      'ST', 'EN', 'BO', 'SI', 'LO', 'AK', 'IK', 'SC',
      'PU', 'KO', 'TO', 'KA', 'UE', 'BR', 'BS', 'FS'
    ];
    return blockTypes.includes(line.trim());
  }
}